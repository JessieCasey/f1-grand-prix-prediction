from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, Optional

import pandas as pd

REQUIRED_COLUMNS = {
    "season",
    "round",
    "raceName",
    "driverRef",
    "predicted_position",
    "predicted_rank",
    "predicted_top5",
    "win_probability",
}

DEFAULT_DISPLAY_COLUMNS = [
    "driverRef",
    "predicted_rank",
    "predicted_position",
    "win_probability",
    "grid",
    "constructorRef",
]


def load_predictions(csv_path: str | Path) -> pd.DataFrame:
    path = Path(csv_path)
    if not path.exists():
        raise FileNotFoundError(f"Prediction CSV '{csv_path}' not found.")
    df = pd.read_csv(path)
    missing = REQUIRED_COLUMNS.difference(df.columns)
    if missing:
        raise ValueError(
            f"CSV '{csv_path}' is missing required columns: {sorted(missing)}. "
            "Generate it with the latest predictor before running the reporter."
        )
    return df


def summarize_predictions(
    frame: pd.DataFrame,
    *,
    top_n: int = 5,
    race_filter: Optional[str] = None,
    include_probabilities: bool = True,
    include_constructor: bool = True,
) -> str:
    """
    Build a human-readable summary for predicted results.

    Args:
        frame: DataFrame produced by `predict_from_csv`.
        top_n: Number of rows per race to include.
        race_filter: Optional substring; only races whose name contains it (case-insensitive) are included.
        include_probabilities: Whether to show win probabilities in the output.
        include_constructor: Whether to show constructor names.
    """
    df = frame.copy()
    if race_filter:
        mask = df["raceName"].str.contains(race_filter, case=False, na=False)
        if not mask.any():
            return f"No races matched filter '{race_filter}'."
        df = df[mask]

    races: list[str] = []
    show_cols = DEFAULT_DISPLAY_COLUMNS.copy()
    if not include_probabilities and "win_probability" in show_cols:
        show_cols.remove("win_probability")
    if not include_constructor and "constructorRef" in show_cols:
        show_cols.remove("constructorRef")

    group_keys = ["season", "round", "raceName"]
    for (season, rnd, name), group in df.groupby(group_keys, sort=True):
        subset = group.nsmallest(top_n, "predicted_rank").sort_values("predicted_rank")
        available_cols = [col for col in show_cols if col in subset.columns]
        if not available_cols:
            continue
        header = f"{season} Round {rnd}: {name}"
        races.append(_format_table(header, subset[available_cols]))

    if not races:
        return "No prediction rows available."

    summary_lines = [
        f"Total races summarised: {df['raceName'].nunique()}",
        f"Unique drivers: {df['driverRef'].nunique()}",
        "",
    ]
    summary_lines.extend(races)
    return "\n".join(summary_lines)


def _format_table(title: str, table: pd.DataFrame) -> str:
    formatted = table.to_string(index=False)
    return f"{title}\n{formatted}\n"


def build_arg_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Summarise F1 prediction results generated by f1_grand_prix_predictor."
    )
    parser.add_argument("--file", default="prediction_results.csv", help="Path to prediction CSV.")
    parser.add_argument("--top", type=int, default=8, help="How many rows per race to display (default: 5).")
    parser.add_argument(
        "--race",
        dest="race_filter",
        default="",
        help="Filter races by substring (case-insensitive). Example: --race 'Australian'.",
    )
    parser.add_argument(
        "--no-probabilities",
        action="store_true",
        help="Hide win probabilities from the summary table.",
    )
    parser.add_argument(
        "--no-constructors",
        action="store_true",
        help="Hide constructor names from the summary table.",
    )
    return parser


def main(argv: Optional[Iterable[str]] = None) -> int:
    parser = build_arg_parser()
    args = parser.parse_args(argv)

    try:
        frame = load_predictions(args.file)
    except Exception as exc:  # noqa: BLE001
        print(f"Failed to load predictions: {exc}")
        return 1

    summary = summarize_predictions(
        frame,
        top_n=args.top,
        race_filter=args.race_filter or None,
        include_probabilities=not args.no_probabilities,
        include_constructor=not args.no_constructors,
    )
    print(summary)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
